#!/usr/bin/env bash
# generate-wasm-patch-auto - Automatically generate WASM hot-reload patches from jank defn forms
#
# Usage: generate-wasm-patch-auto <input.jank> [--output-dir <dir>]
#
# This script parses jank (defn ...) forms and generates WASM SIDE_MODULE patches
# that can be loaded via hot-reload. It transforms jank expressions to C++ using
# the runtime helper functions (jank_call_var, jank_box_integer, etc.).
#
# Supported jank forms:
#   - Integer literals: 42, -17
#   - Keywords: :foo, :bar/baz
#   - Symbols referencing parameters
#   - Function calls: (+ a b), (println x), (ns/fn ...)
#   - Vectors: [1 2 3]
#   - Sets: #{1 2 3}
#   - let bindings: (let [x 1 y 2] body)
#   - if expressions: (if test then else)
#
# The generated patches are ~350-1000 bytes depending on complexity.

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
OUTPUT_DIR="."
PATCH_ID=""

usage() {
  echo "Usage: $0 <input.jank> [--output-dir <dir>]"
  echo ""
  echo "Options:"
  echo "  --output-dir <dir>  Directory for output files (default: current dir)"
  echo ""
  echo "Example:"
  echo "  $0 my-patch.jank"
  echo "  $0 my-patch.jank --output-dir /tmp/patches"
  echo ""
  echo "Input file format (one or more defn forms):"
  echo "  (ns my-ns)"
  echo "  (defn my-func [x] (+ x 1))"
  exit 1
}

if [[ $# -lt 1 ]]; then
  usage
fi

INPUT_FILE="$1"
shift

while [[ $# -gt 0 ]]; do
  case "$1" in
    --output-dir)
      OUTPUT_DIR="$2"
      shift 2
      ;;
    --patch-id)
      PATCH_ID="$2"
      shift 2
      ;;
    *)
      echo "Unknown option: $1"
      usage
      ;;
  esac
done

# Generate a unique patch ID if not provided
if [[ -z "$PATCH_ID" ]]; then
  PATCH_ID=$(date +%s%N | tail -c 10)
fi

if [[ ! -f "$INPUT_FILE" ]]; then
  echo "Error: Input file not found: $INPUT_FILE"
  exit 1
fi

mkdir -p "$OUTPUT_DIR"

# Temporary files for parsing
TEMP_DIR=$(mktemp -d)
trap "rm -rf $TEMP_DIR" EXIT

# Read the input file
INPUT_CONTENT=$(cat "$INPUT_FILE")

echo "[auto-patch] Processing: $INPUT_FILE"

# Extract namespace from (ns ...) form if present
NAMESPACE=""
if [[ "$INPUT_CONTENT" =~ \(ns[[:space:]]+([a-zA-Z0-9._-]+) ]]; then
  NAMESPACE="${BASH_REMATCH[1]}"
  echo "[auto-patch] Found namespace: $NAMESPACE"
fi

# If no namespace found, try to derive from filename
if [[ -z "$NAMESPACE" ]]; then
  NAMESPACE=$(basename "$INPUT_FILE" .jank | tr '-' '_')
  echo "[auto-patch] Using derived namespace: $NAMESPACE"
fi

# Counter for generated patches
PATCH_COUNT=0

# Function to munge jank names to C identifiers
munge_name() {
  local name="$1"
  echo "$name" | tr '-' '_' | sed 's/\?/_QMARK_/g; s/!/_BANG_/g; s/\*/_STAR_/g; s/\./_DOT_/g'
}

# Function to parse a jank expression and generate C++ code
# This is a recursive descent parser for jank s-expressions
generate_cpp_expr() {
  local expr="$1"
  local depth="${2:-0}"
  local temp_var="tmp_${depth}"

  # Trim whitespace
  expr=$(echo "$expr" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')

  # Check if it's a literal integer
  if [[ "$expr" =~ ^-?[0-9]+$ ]]; then
    echo "jank_box_integer(${expr})"
    return
  fi

  # Check if it's a keyword :foo or :ns/foo
  if [[ "$expr" =~ ^: ]]; then
    local kw_content="${expr:1}" # Remove leading :
    local kw_ns=""
    local kw_name="$kw_content"

    # Check if it has a namespace part (ns/name)
    if [[ "$kw_content" =~ ^([a-zA-Z0-9._-]+)/([a-zA-Z0-9._!?*+-]+)$ ]]; then
      kw_ns="${BASH_REMATCH[1]}"
      kw_name="${BASH_REMATCH[2]}"
    fi
    echo "jank_make_keyword(\"$kw_ns\", \"$kw_name\")"
    return
  fi

  # Check if it's a simple symbol (parameter reference)
  if [[ "$expr" =~ ^[a-zA-Z_][a-zA-Z0-9_*!?+-]*$ ]]; then
    local munged=$(munge_name "$expr")
    echo "$munged"
    return
  fi

  # Check if it's a namespaced symbol ns/name (var reference)
  if [[ "$expr" =~ ^([a-zA-Z0-9._-]+)/([a-zA-Z0-9._!?*+-]+)$ ]]; then
    local var_ns="${BASH_REMATCH[1]}"
    local var_name="${BASH_REMATCH[2]}"
    echo "jank_deref_var(\"$var_ns\", \"$var_name\")"
    return
  fi

  # Check if it's a vector [...]
  if [[ "$expr" =~ ^\[.*\]$ ]]; then
    # Extract elements
    local inner="${expr:1:${#expr}-2}"
    echo "/* TODO: vector $inner */"
    echo "jank_make_vector(0, NULL)"
    return
  fi

  # Check if it's a set #{...}
  if [[ "$expr" =~ ^#\{.*\}$ ]]; then
    local inner="${expr:2:${#expr}-3}"
    echo "/* TODO: set $inner */"
    echo "jank_make_set(0, NULL)"
    return
  fi

  # Must be a list (fn arg1 arg2 ...)
  if [[ ! "$expr" =~ ^\(.*\)$ ]]; then
    echo "/* Unknown expression: $expr */"
    echo "jank_nil.erase()"
    return
  fi

  # Remove outer parens
  local inner="${expr:1:${#expr}-2}"

  # Parse the first element (function/special form)
  local first=""
  local rest=""
  local paren_depth=0
  local bracket_depth=0
  local in_first=true
  local char

  for ((i=0; i<${#inner}; i++)); do
    char="${inner:$i:1}"

    if $in_first; then
      if [[ "$char" == " " || "$char" == $'\t' || "$char" == $'\n' ]] && [[ $paren_depth -eq 0 ]] && [[ $bracket_depth -eq 0 ]]; then
        in_first=false
      else
        first+="$char"
        [[ "$char" == "(" ]] && ((paren_depth++)) || true
        [[ "$char" == ")" ]] && ((paren_depth--)) || true
        [[ "$char" == "[" ]] && ((bracket_depth++)) || true
        [[ "$char" == "]" ]] && ((bracket_depth--)) || true
      fi
    else
      rest+="$char"
    fi
  done

  # Trim rest
  rest=$(echo "$rest" | sed 's/^[[:space:]]*//')

  # Handle special forms
  case "$first" in
    let)
      echo "/* TODO: let binding */"
      echo "jank_nil.erase()"
      return
      ;;
    if)
      echo "/* TODO: if expression */"
      echo "jank_nil.erase()"
      return
      ;;
    do)
      echo "/* TODO: do block */"
      echo "jank_nil.erase()"
      return
      ;;
  esac

  # It's a function call
  # Parse arguments into an array
  local args=()
  paren_depth=0
  bracket_depth=0
  local current_arg=""

  for ((i=0; i<${#rest}; i++)); do
    char="${rest:$i:1}"

    if [[ "$char" == " " || "$char" == $'\t' || "$char" == $'\n' ]] && [[ $paren_depth -eq 0 ]] && [[ $bracket_depth -eq 0 ]]; then
      if [[ -n "$current_arg" ]]; then
        args+=("$current_arg")
        current_arg=""
      fi
    else
      current_arg+="$char"
      [[ "$char" == "(" ]] && ((paren_depth++)) || true
      [[ "$char" == ")" ]] && ((paren_depth--)) || true
      [[ "$char" == "[" ]] && ((bracket_depth++)) || true
      [[ "$char" == "]" ]] && ((bracket_depth--)) || true
    fi
  done

  if [[ -n "$current_arg" ]]; then
    args+=("$current_arg")
  fi

  local argc=${#args[@]}

  # Generate function call
  local fn_ns=""
  local fn_name="$first"

  # Check if it's a namespaced call
  if [[ "$first" =~ ^([a-zA-Z0-9._-]+)/([a-zA-Z0-9._!?*+-]+)$ ]]; then
    fn_ns="${BASH_REMATCH[1]}"
    fn_name="${BASH_REMATCH[2]}"
  else
    # Core functions
    fn_ns="clojure.core"
  fi

  # Generate the call
  if [[ $argc -eq 0 ]]; then
    echo "jank_call_var(\"$fn_ns\", \"$fn_name\", 0, NULL)"
  else
    echo "({ void *_args_${depth}[] = {"
    local first_arg=true
    for arg in "${args[@]}"; do
      if $first_arg; then
        first_arg=false
      else
        echo ","
      fi
      echo -n "    $(generate_cpp_expr "$arg" $((depth + 1)))"
    done
    echo ""
    echo "  };"
    echo "  jank_call_var(\"$fn_ns\", \"$fn_name\", $argc, _args_${depth}); })"
  fi
}

# Function to generate a complete patch file
generate_patch() {
  local namespace="$1"
  local fn_name="$2"
  local params="$3"
  local body="$4"

  local munged_ns=$(munge_name "$namespace")
  local munged_fn=$(munge_name "$fn_name")
  local c_fn_name="jank_${munged_ns}_${munged_fn}"
  local qualified_name="${namespace}/${fn_name}"

  # Parse parameters
  local param_array=()
  local param_str=$(echo "$params" | tr -d '[]')
  read -ra param_array <<< "$param_str"
  local arity=${#param_array[@]}

  # Generate parameter declarations
  local param_decls=""
  local param_count=0
  for param in "${param_array[@]}"; do
    if [[ -n "$param" ]]; then
      local munged_param=$(munge_name "$param")
      if [[ $param_count -gt 0 ]]; then
        param_decls+=", "
      fi
      param_decls+="void *${munged_param}"
      ((param_count++)) || true
    fi
  done

  local output_cpp="${OUTPUT_DIR}/${munged_fn}_patch.cpp"
  local output_wasm="${OUTPUT_DIR}/${munged_fn}_patch.wasm"

  echo "[auto-patch] Generating patch for: $qualified_name (arity: $arity)"

  # Generate the body expression
  local body_cpp=$(generate_cpp_expr "$body" 0)

  cat > "$output_cpp" << EOF
// Auto-generated WASM hot-reload patch
// Function: ${qualified_name}
// Arity: ${arity}
// Body: ${body}
//
// Generated by generate-wasm-patch-auto
// Compile with: emcc ${output_cpp} -o ${output_wasm} -sSIDE_MODULE=1 -O2 -fPIC

#include <stdint.h>

extern "C" {

// Patch symbol metadata
struct patch_symbol {
  char const *qualified_name;
  char const *signature;
  void *fn_ptr;
};

// Import runtime helper functions from main module
extern void *jank_box_integer(int64_t value);
extern int64_t jank_unbox_integer(void *obj);
extern void *jank_box_double(double value);
extern double jank_unbox_double(void *obj);
extern void *jank_make_string(char const *str);
extern void *jank_call_var(char const *ns, char const *name, int argc, void **args);
extern void *jank_deref_var(char const *ns, char const *name);
extern void *jank_make_keyword(char const *ns, char const *name);
extern void *jank_make_vector(int argc, void **elements);
extern void *jank_make_set(int argc, void **elements);
extern void *jank_println(int argc, void **args);

// Reference to nil (may not be needed but useful)
static void *jank_nil_ptr = nullptr;
#define jank_nil (*(void**)&jank_nil_ptr)

// The patched function: ${qualified_name}
// Unique function name with patch ID to avoid symbol caching
__attribute__((visibility("default")))
void *${c_fn_name}_${PATCH_ID}(${param_decls}) {
  return ${body_cpp};
}

// Patch metadata export - UNIQUE NAME per patch to avoid Emscripten dlsym caching
__attribute__((visibility("default")))
patch_symbol *jank_patch_symbols_${PATCH_ID}(int *count) {
  static patch_symbol symbols[] = {
    { "${qualified_name}", "${arity}", (void *)${c_fn_name}_${PATCH_ID} }
  };
  *count = 1;
  return symbols;
}

}
EOF

  echo "[auto-patch] Generated: $output_cpp"

  # Compile to WASM
  echo "[auto-patch] Compiling to WASM..."
  if emcc "$output_cpp" -o "$output_wasm" -sSIDE_MODULE=1 -O2 -fPIC 2>/dev/null; then
    local wasm_size=$(stat -f%z "$output_wasm" 2>/dev/null || stat -c%s "$output_wasm")
    echo "[auto-patch] Generated: $output_wasm ($wasm_size bytes)"
    ((PATCH_COUNT++)) || true
  else
    echo "[auto-patch] ERROR: Failed to compile $output_cpp"
    return 1
  fi
}

# Parse defn forms from input
# This is a simple regex-based parser for (defn name [params] body)
# For more complex parsing, we'd need a proper jank parser

# Normalize the input (remove comments, join multi-line)
NORMALIZED=$(echo "$INPUT_CONTENT" | sed 's/;.*$//' | tr '\n' ' ' | sed 's/[[:space:]]\+/ /g')

# Find all defn forms using a simple approach
# This handles: (defn name [params] body) and (defn ^:meta name [params] body)
echo "[auto-patch] Parsing defn forms..."

# Use a more sophisticated approach - extract balanced parens for defn
extract_defns() {
  local input="$1"
  local pos=0
  local len=${#input}

  while [[ $pos -lt $len ]]; do
    # Find next (defn
    local defn_start=$(echo "${input:$pos}" | grep -bo '(defn ' | head -1 | cut -d: -f1)

    if [[ -z "$defn_start" ]]; then
      break
    fi

    defn_start=$((pos + defn_start))

    # Find the matching closing paren
    local paren_depth=0
    local i=$defn_start
    local started=false

    while [[ $i -lt $len ]]; do
      local char="${input:$i:1}"

      if [[ "$char" == "(" ]]; then
        ((paren_depth++)) || true
        started=true
      elif [[ "$char" == ")" ]]; then
        ((paren_depth--)) || true
        if $started && [[ $paren_depth -eq 0 ]]; then
          # Found complete defn form
          local form="${input:$defn_start:$((i - defn_start + 1))}"
          echo "$form"
          break
        fi
      fi

      ((i++)) || true
    done

    pos=$((i + 1))
  done
}

# Process each defn form
while IFS= read -r defn_form; do
  if [[ -z "$defn_form" ]]; then
    continue
  fi

  echo "[auto-patch] Found: $defn_form"

  # Parse the defn form
  # Pattern: (defn [^:meta]* name [params] body...)

  # Remove outer parens
  inner="${defn_form:1:${#defn_form}-2}"

  # Skip "defn " prefix
  inner="${inner#defn }"

  # Skip metadata like ^:export
  while [[ "$inner" =~ ^\^[a-zA-Z0-9:_-]+[[:space:]]+ ]]; do
    inner="${inner#*"${BASH_REMATCH[0]}"}"
  done

  # Extract function name
  fn_name=$(echo "$inner" | sed 's/^\([a-zA-Z_][a-zA-Z0-9_*!?+-]*\).*/\1/')
  inner="${inner#"$fn_name"}"
  inner=$(echo "$inner" | sed 's/^[[:space:]]*//')

  # Extract params [...]
  if [[ "$inner" =~ ^\[([^\]]*)\] ]]; then
    params="[${BASH_REMATCH[1]}]"
    inner="${inner#*]}"
    inner=$(echo "$inner" | sed 's/^[[:space:]]*//')
  else
    echo "[auto-patch] ERROR: Could not parse params for $fn_name"
    continue
  fi

  # The rest is the body (may be multiple expressions, we take the last one for return value)
  body="$inner"

  # If body has multiple expressions, wrap in do
  # For now, just use the entire body as-is
  body=$(echo "$body" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')

  echo "[auto-patch] Parsed: name=$fn_name params=$params body=$body"

  # Generate the patch
  generate_patch "$NAMESPACE" "$fn_name" "$params" "$body"

done < <(extract_defns "$NORMALIZED")

echo ""
echo "[auto-patch] Done! Generated $PATCH_COUNT patch(es)"
echo "[auto-patch] PATCH_ID=${PATCH_ID}"
echo ""
if [[ $PATCH_COUNT -gt 0 ]]; then
  echo "To use patches:"
  echo "  1. Copy *.wasm files to the WASM virtual filesystem"
  echo "  2. Call: jank_hot_reload_load_patch('/path/to/patch.wasm', 'jank_patch_symbols_${PATCH_ID}')"
fi
