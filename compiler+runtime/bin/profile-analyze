#!/usr/bin/env python3
"""
jank profile analyzer - Visualize jank profiling data

Usage:
    ./bin/profile-analyze profile.txt                  # Print summary
    ./bin/profile-analyze profile.txt --flamegraph     # Output flamegraph format
    ./bin/profile-analyze profile.txt --html out.html  # Generate HTML timeline
    ./bin/profile-analyze profile.txt --tree           # Print call tree
"""

import sys
import argparse
import json
from dataclasses import dataclass, field
from typing import Optional
from collections import defaultdict


@dataclass
class ProfileEvent:
    timestamp_ns: int
    event_type: str  # 'enter', 'exit', 'report'
    region: str


@dataclass
class RegionStats:
    name: str
    total_ns: int = 0
    self_ns: int = 0  # Time excluding children
    count: int = 0
    min_ns: int = float('inf')
    max_ns: int = 0
    children_time_ns: int = 0


@dataclass
class CallNode:
    region: str
    start_ns: int
    end_ns: int = 0
    children: list = field(default_factory=list)
    parent: Optional['CallNode'] = None

    @property
    def duration_ns(self) -> int:
        return self.end_ns - self.start_ns if self.end_ns else 0

    @property
    def self_time_ns(self) -> int:
        children_time = sum(c.duration_ns for c in self.children)
        return self.duration_ns - children_time


def parse_profile(filepath: str) -> list[ProfileEvent]:
    """Parse jank profile file into events."""
    events = []
    with open(filepath, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or not line.startswith('jank::profile'):
                continue

            parts = line.split(None, 3)  # Split on whitespace, max 4 parts
            if len(parts) < 4:
                continue

            # jank::profile <timestamp> <event_type> <region>
            try:
                timestamp_ns = int(parts[1])
                event_type = parts[2]
                region = parts[3]
                events.append(ProfileEvent(timestamp_ns, event_type, region))
            except (ValueError, IndexError):
                continue

    return events


def build_call_tree(events: list[ProfileEvent]) -> list[CallNode]:
    """Build a call tree from profile events."""
    roots = []
    stack = []

    for event in events:
        if event.event_type == 'enter':
            node = CallNode(region=event.region, start_ns=event.timestamp_ns)
            if stack:
                node.parent = stack[-1]
                stack[-1].children.append(node)
            else:
                roots.append(node)
            stack.append(node)

        elif event.event_type == 'exit':
            if stack and stack[-1].region == event.region:
                stack[-1].end_ns = event.timestamp_ns
                stack.pop()
            else:
                # Mismatched exit - try to find matching entry
                for i in range(len(stack) - 1, -1, -1):
                    if stack[i].region == event.region:
                        stack[i].end_ns = event.timestamp_ns
                        stack[:] = stack[:i]
                        break

    return roots


def compute_stats(roots: list[CallNode]) -> dict[str, RegionStats]:
    """Compute statistics for each region."""
    stats = defaultdict(lambda: RegionStats(name=""))

    def visit(node: CallNode):
        s = stats[node.region]
        s.name = node.region
        s.count += 1
        s.total_ns += node.duration_ns
        s.self_ns += node.self_time_ns
        s.min_ns = min(s.min_ns, node.duration_ns)
        s.max_ns = max(s.max_ns, node.duration_ns)

        for child in node.children:
            visit(child)

    for root in roots:
        visit(root)

    return dict(stats)


def ns_to_ms(ns: int) -> float:
    return ns / 1_000_000


def ns_to_human(ns: int) -> str:
    """Convert nanoseconds to human readable format."""
    if ns < 1_000:
        return f"{ns}ns"
    elif ns < 1_000_000:
        return f"{ns/1_000:.2f}us"
    elif ns < 1_000_000_000:
        return f"{ns/1_000_000:.2f}ms"
    else:
        return f"{ns/1_000_000_000:.2f}s"


def print_summary(stats: dict[str, RegionStats], top_n: int = 30):
    """Print a summary of profiling data."""
    print("=" * 80)
    print("JANK PROFILE SUMMARY")
    print("=" * 80)
    print()

    # Sort by total time descending
    sorted_stats = sorted(stats.values(), key=lambda s: s.total_ns, reverse=True)

    total_time = sum(s.self_ns for s in sorted_stats)

    print(f"Total measured time: {ns_to_human(total_time)}")
    print(f"Unique regions: {len(stats)}")
    print()

    print(f"{'Region':<45} {'Total':>12} {'Self':>12} {'Count':>8} {'Avg':>12}")
    print("-" * 89)

    for s in sorted_stats[:top_n]:
        avg_ns = s.total_ns // s.count if s.count > 0 else 0
        print(f"{s.name:<45} {ns_to_human(s.total_ns):>12} {ns_to_human(s.self_ns):>12} {s.count:>8} {ns_to_human(avg_ns):>12}")

    if len(sorted_stats) > top_n:
        print(f"... and {len(sorted_stats) - top_n} more regions")

    print()

    # Print top by self time (actual work, not including children)
    print("TOP BY SELF TIME (actual work, excluding nested calls):")
    print("-" * 89)
    sorted_by_self = sorted(stats.values(), key=lambda s: s.self_ns, reverse=True)
    for s in sorted_by_self[:15]:
        pct = (s.self_ns / total_time * 100) if total_time > 0 else 0
        print(f"{s.name:<45} {ns_to_human(s.self_ns):>12} ({pct:>5.1f}%)")


def print_tree(roots: list[CallNode], max_depth: int = 10):
    """Print call tree."""
    print("=" * 80)
    print("CALL TREE")
    print("=" * 80)

    def print_node(node: CallNode, depth: int = 0):
        if depth > max_depth:
            return
        indent = "  " * depth
        duration = ns_to_human(node.duration_ns)
        self_time = ns_to_human(node.self_time_ns)
        print(f"{indent}{node.region}: {duration} (self: {self_time})")
        for child in node.children:
            print_node(child, depth + 1)

    for root in roots:
        print_node(root)
        print()


def output_flamegraph(roots: list[CallNode]):
    """Output in flamegraph format (collapsed stacks)."""
    stacks = defaultdict(int)

    def collect_stacks(node: CallNode, stack: list[str]):
        current_stack = stack + [node.region]
        # Add self time to this stack
        if node.self_time_ns > 0:
            stack_str = ";".join(current_stack)
            stacks[stack_str] += node.self_time_ns // 1000  # Convert to microseconds

        for child in node.children:
            collect_stacks(child, current_stack)

    for root in roots:
        collect_stacks(root, [])

    # Output in flamegraph format
    for stack, time_us in sorted(stacks.items()):
        if time_us > 0:
            print(f"{stack} {time_us}")


def generate_html(roots: list[CallNode], stats: dict[str, RegionStats], output_path: str):
    """Generate an HTML timeline visualization."""

    # Find time bounds
    min_time = float('inf')
    max_time = 0

    def find_bounds(node: CallNode):
        nonlocal min_time, max_time
        min_time = min(min_time, node.start_ns)
        if node.end_ns:
            max_time = max(max_time, node.end_ns)
        for child in node.children:
            find_bounds(child)

    for root in roots:
        find_bounds(root)

    total_duration = max_time - min_time

    # Build timeline data
    timeline_data = []

    def collect_for_timeline(node: CallNode, depth: int = 0):
        if node.duration_ns > 0:
            start_pct = ((node.start_ns - min_time) / total_duration) * 100
            width_pct = (node.duration_ns / total_duration) * 100
            timeline_data.append({
                'region': node.region,
                'start_pct': start_pct,
                'width_pct': width_pct,
                'depth': depth,
                'duration': ns_to_human(node.duration_ns),
                'self_time': ns_to_human(node.self_time_ns),
                'start_ns': node.start_ns,
                'end_ns': node.end_ns,
                'duration_ns': node.duration_ns,
                'self_time_ns': node.self_time_ns,
            })
        for child in node.children:
            collect_for_timeline(child, depth + 1)

    for root in roots:
        collect_for_timeline(root)

    # Serialize call tree for JavaScript (for filtering by time selection)
    def serialize_tree(nodes: list[CallNode], max_depth: int = 15) -> list:
        """Serialize call tree to JSON-friendly structure."""
        result = []
        def serialize_node(node: CallNode, depth: int):
            if depth > max_depth:
                return None
            return {
                'region': node.region,
                'start_ns': node.start_ns,
                'end_ns': node.end_ns,
                'duration_ns': node.duration_ns,
                'self_time_ns': node.self_time_ns,
                'children': [c for c in (serialize_node(child, depth + 1) for child in node.children) if c is not None]
            }
        for node in nodes:
            serialized = serialize_node(node, 0)
            if serialized:
                result.append(serialized)
        return result

    tree_json = json.dumps(serialize_tree(roots), separators=(',', ':'))

    # Generate colors based on region name
    def region_color(name: str) -> str:
        # Hash-based color
        h = hash(name) % 360
        return f"hsl({h}, 70%, 60%)"

    # Build stats table
    sorted_stats = sorted(stats.values(), key=lambda s: s.total_ns, reverse=True)
    total_self = sum(s.self_ns for s in sorted_stats)

    stats_rows = ""
    for s in sorted_stats[:50]:
        pct = (s.self_ns / total_self * 100) if total_self > 0 else 0
        avg = s.total_ns // s.count if s.count > 0 else 0
        stats_rows += f"""
        <tr>
            <td style="background: {region_color(s.name)}; width: 10px;"></td>
            <td>{s.name}</td>
            <td>{ns_to_human(s.total_ns)}</td>
            <td>{ns_to_human(s.self_ns)}</td>
            <td>{pct:.1f}%</td>
            <td>{s.count}</td>
            <td>{ns_to_human(avg)}</td>
        </tr>
        """

    # Build hierarchical call tree for nested view
    # Aggregate children by region name to show unique callee patterns
    @dataclass
    class TreeNode:
        region: str
        total_ns: int = 0
        self_ns: int = 0
        count: int = 0
        children: dict = field(default_factory=dict)  # region -> TreeNode

    def build_aggregated_tree(call_nodes: list[CallNode], max_depth: int = 10) -> dict[str, TreeNode]:
        """Build aggregated tree from call nodes, merging same-named children."""
        result = {}

        def add_to_tree(node: CallNode, target: dict, depth: int):
            if depth > max_depth:
                return
            if node.region not in target:
                target[node.region] = TreeNode(region=node.region)
            t = target[node.region]
            t.total_ns += node.duration_ns
            t.self_ns += node.self_time_ns
            t.count += 1

            for child in node.children:
                add_to_tree(child, t.children, depth + 1)

        for node in call_nodes:
            add_to_tree(node, result, 0)

        return result

    def generate_tree_html(tree_nodes: dict[str, TreeNode], total_time: int, depth: int = 0) -> str:
        """Generate nested HTML for call tree."""
        if not tree_nodes:
            return ""

        # Sort by total time descending
        sorted_nodes = sorted(tree_nodes.values(), key=lambda n: n.total_ns, reverse=True)

        # Limit children shown at deeper levels (increased limits)
        max_children = 50 if depth < 2 else 30 if depth < 4 else 20
        sorted_nodes = sorted_nodes[:max_children]

        html = ""
        for node in sorted_nodes:
            pct = (node.self_ns / total_time * 100) if total_time > 0 else 0
            avg = node.total_ns // node.count if node.count > 0 else 0
            has_children = bool(node.children)
            node_id = f"node_{hash(node.region) % 1000000}_{depth}"

            # Calculate bar width for visual representation
            bar_pct = min((node.total_ns / total_time * 100) * 2, 100)  # Scale up for visibility

            children_html = generate_tree_html(node.children, total_time, depth + 1) if has_children else ""

            expand_icon = "&#9660;" if has_children else "&#183;"  # ▼ (expanded) and · as HTML entities
            expand_class = "expandable" if has_children else ""

            html += f"""
            <div class="tree-row {expand_class}" data-depth="{depth}" data-node-id="{node_id}">
                <div class="tree-cell tree-name" style="padding-left: {depth * 20 + 8}px;">
                    <span class="expand-icon" onclick="toggleNode('{node_id}')">{expand_icon}</span>
                    <span class="color-dot" style="background: {region_color(node.region)};"></span>
                    <span class="region-name">{node.region}</span>
                </div>
                <div class="tree-cell">{ns_to_human(node.total_ns)}</div>
                <div class="tree-cell">{ns_to_human(node.self_ns)}</div>
                <div class="tree-cell">{pct:.1f}%</div>
                <div class="tree-cell">{node.count}</div>
                <div class="tree-cell">{ns_to_human(avg)}</div>
                <div class="tree-cell tree-bar">
                    <div class="bar" style="width: {bar_pct}%; background: {region_color(node.region)};"></div>
                </div>
            </div>
            <div class="tree-children" id="{node_id}" style="display: block;">
                {children_html}
            </div>
            """

        return html

    aggregated_tree = build_aggregated_tree(roots)
    tree_html = generate_tree_html(aggregated_tree, total_duration)

    # Build timeline rows
    max_depth = max((d['depth'] for d in timeline_data), default=0)
    row_height = 25

    # Aggregate small items by region and depth into time buckets
    # This prevents thousands of tiny calls from being filtered out
    MIN_VISIBLE_PCT = 0.1  # Minimum width to render (lowered from 0.05)
    BUCKET_PCT = 0.5  # Time bucket size for aggregation

    # Group items: large ones shown directly, small ones aggregated
    direct_items = []
    aggregate_buckets = defaultdict(lambda: defaultdict(lambda: {'count': 0, 'total_ns': 0, 'regions': set()}))

    for item in timeline_data:
        if item['width_pct'] >= MIN_VISIBLE_PCT:
            direct_items.append(item)
        else:
            # Aggregate by depth and time bucket
            bucket_idx = int(item['start_pct'] / BUCKET_PCT)
            depth = item['depth']
            key = (depth, bucket_idx)
            aggregate_buckets[key][item['region']]['count'] += 1
            # We don't have raw ns here, estimate from width_pct
            aggregate_buckets[key][item['region']]['total_ns'] += item['width_pct']

    timeline_items = ""

    # Render direct (large enough) items
    for item in direct_items:
        top = item['depth'] * row_height
        timeline_items += f"""
        <div class="timeline-item"
             style="left: {item['start_pct']}%; width: {item['width_pct']}%; top: {top}px; background: {region_color(item['region'])};"
             title="{item['region']}&#10;Duration: {item['duration']}&#10;Self: {item['self_time']}">
            {item['region'] if item['width_pct'] > 2 else ''}
        </div>
        """

    # Render aggregated buckets
    for (depth, bucket_idx), regions in aggregate_buckets.items():
        # Find the dominant region in this bucket
        dominant_region = max(regions.keys(), key=lambda r: regions[r]['count'])
        total_count = sum(r['count'] for r in regions.values())
        total_width = sum(r['total_ns'] for r in regions.values())

        if total_width < MIN_VISIBLE_PCT * 0.5:
            continue  # Still too small even aggregated

        start_pct = bucket_idx * BUCKET_PCT
        width_pct = min(total_width, BUCKET_PCT * 0.9)  # Cap at bucket size
        top = depth * row_height

        # Show aggregated bar with hatched pattern to indicate aggregation
        region_list = ', '.join(f"{r}({regions[r]['count']})" for r in sorted(regions.keys(), key=lambda r: -regions[r]['count'])[:5])
        timeline_items += f"""
        <div class="timeline-item aggregated"
             style="left: {start_pct}%; width: {width_pct}%; top: {top}px; background: repeating-linear-gradient(45deg, {region_color(dominant_region)}, {region_color(dominant_region)} 2px, rgba(0,0,0,0.3) 2px, rgba(0,0,0,0.3) 4px);"
             title="Aggregated ({total_count} calls)&#10;{region_list}">
            {total_count} calls
        </div>
        """

    html = f"""<!DOCTYPE html>
<html>
<head>
    <title>jank Profile Visualization</title>
    <style>
        body {{ font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif; margin: 20px; background: #1a1a2e; color: #eee; }}
        h1, h2 {{ color: #00d4ff; }}
        .container {{ max-width: 1400px; margin: 0 auto; }}

        .timeline-wrapper {{
            position: relative;
            margin-bottom: 30px;
        }}
        .timeline-container {{
            position: relative;
            width: 100%;
            height: {(max_depth + 1) * row_height + 20}px;
            background: #16213e;
            border-radius: 8px;
            overflow-x: auto;
            cursor: default;
        }}
        .timeline-selection {{
            position: absolute;
            top: 0;
            height: 100%;
            background: rgba(0, 212, 255, 0.2);
            border-left: 2px solid #00d4ff;
            border-right: 2px solid #00d4ff;
            pointer-events: none;
            z-index: 50;
        }}
        .timeline-info {{
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            font-size: 13px;
        }}
        .timeline-info .selection-info {{
            color: #00d4ff;
        }}
        .timeline-info button {{
            background: #0f3460;
            color: #00d4ff;
            border: 1px solid #00d4ff;
            padding: 4px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }}
        .timeline-info button:hover {{
            background: #1f4068;
        }}

        .timeline-item {{
            position: absolute;
            height: {row_height - 2}px;
            border-radius: 3px;
            font-size: 11px;
            color: #fff;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding: 2px 4px;
            box-sizing: border-box;
            cursor: pointer;
            border: 1px solid rgba(0,0,0,0.2);
        }}

        .timeline-item:hover {{
            filter: brightness(1.2);
            z-index: 100;
        }}

        .timeline-item.aggregated {{
            font-weight: bold;
            font-size: 10px;
            border: 1px dashed rgba(255,255,255,0.5);
        }}

        table {{
            width: 100%;
            border-collapse: collapse;
            background: #16213e;
            border-radius: 8px;
            overflow: hidden;
        }}
        th {{ background: #0f3460; padding: 12px 8px; text-align: left; }}
        td {{ padding: 8px; border-bottom: 1px solid #0f3460; }}
        tr:hover {{ background: #1f4068; }}

        .summary {{
            background: #16213e;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }}
        .summary span {{
            display: inline-block;
            margin-right: 30px;
            color: #00d4ff;
        }}

        /* Tree view styles */
        .tree-container {{
            background: #16213e;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 30px;
        }}
        .tree-header {{
            display: flex;
            background: #0f3460;
            padding: 12px 8px;
            font-weight: bold;
        }}
        .tree-header .tree-cell {{
            flex-shrink: 0;
        }}
        .tree-row {{
            display: flex;
            border-bottom: 1px solid #0f3460;
            align-items: center;
        }}
        .tree-row:hover {{
            background: #1f4068;
        }}
        .tree-row.expandable {{
            cursor: pointer;
        }}
        .tree-cell {{
            padding: 6px 8px;
            flex-shrink: 0;
        }}
        .tree-cell.tree-name {{
            flex: 1;
            min-width: 300px;
            display: flex;
            align-items: center;
            gap: 6px;
        }}
        .tree-cell:nth-child(2) {{ width: 80px; }}  /* Total */
        .tree-cell:nth-child(3) {{ width: 80px; }}  /* Self */
        .tree-cell:nth-child(4) {{ width: 60px; }}  /* Self % */
        .tree-cell:nth-child(5) {{ width: 70px; }}  /* Count */
        .tree-cell:nth-child(6) {{ width: 80px; }}  /* Avg */
        .tree-cell.tree-bar {{ width: 150px; }}
        .tree-bar .bar {{
            height: 12px;
            border-radius: 2px;
            min-width: 2px;
        }}
        .expand-icon {{
            width: 16px;
            text-align: center;
            color: #00d4ff;
            font-size: 10px;
            cursor: pointer;
            user-select: none;
        }}
        .expand-icon:hover {{
            color: #fff;
        }}
        .color-dot {{
            width: 10px;
            height: 10px;
            border-radius: 2px;
            flex-shrink: 0;
        }}
        .region-name {{
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }}
        .tree-children {{
            /* Children container - hidden by default */
        }}
        .tree-controls {{
            margin-bottom: 10px;
        }}
        .tree-controls button {{
            background: #0f3460;
            color: #00d4ff;
            border: 1px solid #00d4ff;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
            font-size: 13px;
        }}
        .tree-controls button:hover {{
            background: #1f4068;
        }}
    </style>
</head>
<body>
    <div class="container">
        <h1>jank Profile Visualization</h1>

        <div class="summary">
            <span>Total Time: {ns_to_human(total_duration)}</span>
            <span>Regions: {len(stats)}</span>
            <span>Events: {len(timeline_data)}</span>
        </div>

        <h2>Timeline</h2>
        <div class="timeline-wrapper">
            <div class="timeline-container" id="timelineContainer">
                {timeline_items}
            </div>
        </div>

        <h2>Call Tree</h2>
        <div class="tree-controls">
            <button onclick="expandAll()">Expand All</button>
            <button onclick="collapseAll()">Collapse All</button>
            <button onclick="expandLevel(1)">Expand Level 1</button>
            <button onclick="expandLevel(2)">Expand Level 2</button>
        </div>
        <div class="tree-container">
            <div class="tree-header">
                <div class="tree-cell tree-name">Function</div>
                <div class="tree-cell">Total</div>
                <div class="tree-cell">Self</div>
                <div class="tree-cell">Self %</div>
                <div class="tree-cell">Count</div>
                <div class="tree-cell">Avg</div>
                <div class="tree-cell tree-bar">Time</div>
            </div>
            {tree_html}
        </div>

        <h2>Statistics (flat view, by total time)</h2>
        <table>
            <tr>
                <th></th>
                <th>Region</th>
                <th>Total</th>
                <th>Self</th>
                <th>Self %</th>
                <th>Count</th>
                <th>Avg</th>
            </tr>
            {stats_rows}
        </table>
    </div>

    <script>
        // ==================== Tree Expand/Collapse ====================
        function toggleNode(nodeId) {{
            const children = document.getElementById(nodeId);
            const row = document.querySelector(`[data-node-id="${{nodeId}}"]`);
            if (!children || !row) return;
            const icon = row.querySelector('.expand-icon');

            if (children.style.display === 'none') {{
                children.style.display = 'block';
                icon.innerHTML = '&#9660;';  // ▼
            }} else {{
                children.style.display = 'none';
                icon.innerHTML = '&#9654;';  // ▶
            }}
        }}

        function expandAll() {{
            document.querySelectorAll('.tree-children').forEach(el => {{
                el.style.display = 'block';
            }});
            document.querySelectorAll('.expandable .expand-icon').forEach(el => {{
                el.innerHTML = '&#9660;';  // ▼
            }});
        }}

        function collapseAll() {{
            document.querySelectorAll('.tree-children').forEach(el => {{
                el.style.display = 'none';
            }});
            document.querySelectorAll('.expandable .expand-icon').forEach(el => {{
                el.innerHTML = '&#9654;';  // ▶
            }});
        }}

        function expandLevel(targetDepth) {{
            collapseAll();
            document.querySelectorAll('.tree-row.expandable').forEach(row => {{
                const depth = parseInt(row.dataset.depth);
                if (depth < targetDepth) {{
                    const nodeId = row.dataset.nodeId;
                    const children = document.getElementById(nodeId);
                    const icon = row.querySelector('.expand-icon');
                    if (children) {{
                        children.style.display = 'block';
                        icon.innerHTML = '&#9660;';  // ▼
                    }}
                }}
            }});
        }}

        function attachTreeClickHandlers() {{
            document.querySelectorAll('.tree-row.expandable').forEach(row => {{
                row.addEventListener('click', (e) => {{
                    if (!e.target.classList.contains('expand-icon')) {{
                        const nodeId = row.dataset.nodeId;
                        toggleNode(nodeId);
                    }}
                }});
            }});
        }}

        // Initial attachment
        attachTreeClickHandlers();
    </script>
</body>
</html>
"""

    with open(output_path, 'w') as f:
        f.write(html)

    print(f"HTML visualization written to: {output_path}")


def main():
    parser = argparse.ArgumentParser(description='Analyze jank profile data')
    parser.add_argument('profile_file', help='Path to profile file')
    parser.add_argument('--flamegraph', action='store_true',
                        help='Output in flamegraph collapsed format')
    parser.add_argument('--html', metavar='OUTPUT',
                        help='Generate HTML timeline visualization')
    parser.add_argument('--tree', action='store_true',
                        help='Print call tree')
    parser.add_argument('--top', type=int, default=30,
                        help='Number of top regions to show (default: 30)')

    args = parser.parse_args()

    # Parse profile
    events = parse_profile(args.profile_file)
    if not events:
        print(f"No profile events found in {args.profile_file}", file=sys.stderr)
        sys.exit(1)

    print(f"Parsed {len(events)} events", file=sys.stderr)

    # Build call tree
    roots = build_call_tree(events)
    stats = compute_stats(roots)

    if args.flamegraph:
        output_flamegraph(roots)
    elif args.html:
        generate_html(roots, stats, args.html)
    elif args.tree:
        print_tree(roots)
    else:
        print_summary(stats, args.top)


if __name__ == '__main__':
    main()
