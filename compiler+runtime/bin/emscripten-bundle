#!/usr/bin/env bash

set -euo pipefail

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
  here="$(cd "$(dirname "$0")" && pwd)"
else
  here="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
fi
repo_root="${here}/.."
build_dir="${repo_root}/build-wasm"
native_build_dir="${repo_root}/build"
output_dir=""
output_name="jank"
skip_build=false
run_after=false
jank_source=""
node_args=()
verbose=false

usage() {
  cat <<'USAGE'
Usage: emscripten-bundle [OPTIONS] [jank-source] [-- [extra cmake configure args]]

Runs emcmake/cmake with -Djank_target_wasm=on and produces a wasm-friendly build tree,
then links the result into runnable .js/.wasm/.html files.

If a jank source file is provided, it will be compiled using the native jank compiler
and linked into the WASM bundle.

Options:
  -h, --help              Show this help message
  --build-dir DIR         CMake build directory for WASM (default: build-wasm)
  --native-build-dir DIR  Native build directory with jank compiler (default: build)
  --output-dir DIR        Output directory for .js/.wasm/.html (default: build-dir)
  --output-name NAME      Base name for output files (default: jank, or source basename)
  --skip-build            Skip cmake build, only run em++ linking step
  --run                   Run the generated .js file with Node.js after building
  --node-args ARGS        Extra arguments to pass to Node.js (implies --run)
  -v, --verbose           Enable verbose output (shows compilation commands)

Any arguments after -- are forwarded directly to the emcmake configure invocation.

Examples:
  emscripten-bundle                           # Build runtime and generate jank.js/jank.wasm
  emscripten-bundle eita.jank                 # Compile eita.jank and bundle into eita.js/eita.wasm
  emscripten-bundle --run eita.jank           # Compile and run with Node.js
  emscripten-bundle --skip-build --run        # Just link and run (if already built)
  emscripten-bundle --output-name hello       # Generate hello.js/hello.wasm/hello.html
USAGE
}

cmake_args=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --build-dir)
      if [[ $# -lt 2 ]]; then
        echo "error: --build-dir expects an argument" >&2
        exit 1
      fi
      build_dir="$2"
      shift 2
      ;;
    --native-build-dir)
      if [[ $# -lt 2 ]]; then
        echo "error: --native-build-dir expects an argument" >&2
        exit 1
      fi
      native_build_dir="$2"
      shift 2
      ;;
    --output-dir)
      if [[ $# -lt 2 ]]; then
        echo "error: --output-dir expects an argument" >&2
        exit 1
      fi
      output_dir="$2"
      shift 2
      ;;
    --output-name)
      if [[ $# -lt 2 ]]; then
        echo "error: --output-name expects an argument" >&2
        exit 1
      fi
      output_name="$2"
      shift 2
      ;;
    --skip-build)
      skip_build=true
      shift
      ;;
    --run)
      run_after=true
      shift
      ;;
    -v|--verbose)
      verbose=true
      shift
      ;;
    --node-args)
      if [[ $# -lt 2 ]]; then
        echo "error: --node-args expects an argument" >&2
        exit 1
      fi
      run_after=true
      node_args+=($2)
      shift 2
      ;;
    --)
      shift
      cmake_args+=("$@")
      break
      ;;
    *.jank)
      # Jank source file
      jank_source="$1"
      shift
      ;;
    *)
      cmake_args+=("$1")
      shift
      ;;
  esac
done

# If jank source provided but no output name specified, use source basename
if [[ -n "${jank_source}" && "${output_name}" == "jank" ]]; then
  output_name="$(basename "${jank_source}" .jank)"
fi

# Default output_dir to build_dir if not specified
if [[ -z "${output_dir}" ]]; then
  output_dir="${build_dir}"
fi

for tool in emcmake cmake em++; do
  if ! command -v "$tool" >/dev/null 2>&1; then
    echo "error: required tool '$tool' not found in PATH" >&2
    exit 1
  fi
done

if [[ "${run_after}" == "true" ]]; then
  if ! command -v node >/dev/null 2>&1; then
    echo "error: --run requires 'node' in PATH" >&2
    exit 1
  fi
fi

mkdir -p "${build_dir}"
mkdir -p "${output_dir}"

run() {
  echo "[emscripten-bundle] $*"
  "$@"
}

# --- Compile jank source if provided ---
compiled_objects=()
entrypoint_cpp=""
aot_mode=false  # Whether we're using true AOT compilation

# Always include clojure.core if it exists
clojure_core_cpp="${output_dir}/clojure_core_generated.cpp"
if [[ -f "${clojure_core_cpp}" ]]; then
  echo "[emscripten-bundle] Found pre-compiled clojure.core: ${clojure_core_cpp}"
  compiled_objects+=("${clojure_core_cpp}")
else
  echo "[emscripten-bundle] WARNING: clojure.core not pre-compiled, some functions may not be available"
  echo "[emscripten-bundle]          Run: ./build/jank run --codegen wasm-aot --save-cpp --save-cpp-path build-wasm/clojure_core_generated.cpp src/jank/clojure/core_wasm.jank"
fi

# Include clojure.set if it exists
clojure_set_cpp="${output_dir}/clojure_set_generated.cpp"
if [[ -f "${clojure_set_cpp}" ]]; then
  echo "[emscripten-bundle] Found pre-compiled clojure.set: ${clojure_set_cpp}"
  compiled_objects+=("${clojure_set_cpp}")
fi

if [[ -n "${jank_source}" ]]; then
  if [[ ! -f "${jank_source}" ]]; then
    echo "error: jank source file not found: ${jank_source}" >&2
    exit 1
  fi
  
  native_jank="${native_build_dir}/jank"
  if [[ ! -x "${native_jank}" ]]; then
    echo "error: native jank compiler not found: ${native_jank}" >&2
    echo "       Build the native compiler first with ./bin/compile" >&2
    exit 1
  fi
  
  echo "[emscripten-bundle] Compiling jank source: ${jank_source}"
  
  # Get the module name from the source file
  jank_source_abs="$(cd "$(dirname "${jank_source}")" && pwd)/$(basename "${jank_source}")"
  jank_source_dir="$(dirname "${jank_source_abs}")"
  module_name="$(basename "${jank_source}" .jank)"
  
  # Read the jank source file for embedding (fallback mode)
  jank_source_content=$(cat "${jank_source}")
  
  # Use C++ codegen so we can compile with emscripten
  # The native jank compiler generates C++ code that em++ can compile to WASM
  cpp_output="${output_dir}/${module_name}_generated.cpp"
  
  # Remove old generated file to start fresh (jank appends to file)
  rm -f "${cpp_output}"
  
  echo "[emscripten-bundle] Attempting true AOT compilation with --codegen wasm-aot..."

  # Build the jank command
  jank_cmd=("${native_jank}" run \
    --codegen wasm-aot \
    --module-path src/jank \
    --save-cpp \
    --save-cpp-path "${cpp_output}" \
    "${jank_source}")

  if [[ "${verbose}" == "true" ]]; then
    echo "[emscripten-bundle] Running AOT compile command:"
    echo "[emscripten-bundle]   ${jank_cmd[@]}"
  fi

  # Try to compile module with wasm-aot codegen using 'run' command
  # The 'run' command evaluates the file and generates AOT code
  if "${jank_cmd[@]}" 2>&1; then
    echo "[emscripten-bundle] AOT compilation successful!"
    aot_mode=true
  else
    echo "[emscripten-bundle] AOT compilation failed, falling back to runtime eval mode"
    aot_mode=false
  fi
  
  if [[ "${aot_mode}" == "true" && -f "${cpp_output}" ]]; then
    echo "[emscripten-bundle] Using pre-compiled C++: ${cpp_output}"
    compiled_objects+=("${cpp_output}")
    
    # Generate an entrypoint that calls the pre-compiled module init
    entrypoint_cpp="${output_dir}/${module_name}_entry.cpp"
    
    # Munge the module name for C++ symbol generation (replace - with _)
    munged_module_name="${module_name//-/_}"
    
    # Detect dependencies from generated code (find all jank_load_* functions except the main one)
    # These are dependencies that need to be loaded before the main module
    deps_extern=""
    deps_load=""
    
    # Find all jank_load_X functions in the generated code that are module loaders
    # These are defined as "void* jank_load_X()" at the top level
    while IFS= read -r line; do
      if [[ "$line" =~ ^[[:space:]]*void\*[[:space:]]+jank_load_([a-zA-Z_][a-zA-Z0-9_]*)\(\)[[:space:]]*\{ ]]; then
        dep_func="jank_load_${BASH_REMATCH[1]}"
        # Skip the main module itself
        if [[ "$dep_func" != "jank_load_${munged_module_name}" ]]; then
          # Convert underscores back to dots for display
          dep_name="${BASH_REMATCH[1]//_/.}"
          deps_extern+="  void* ${dep_func}();\\n"
          deps_load+="  printf(\"[jank-wasm] Loading dependency: ${dep_name}...\\\\n\");\\n"
          deps_load+="  ${dep_func}();\\n"
        fi
      fi
    done < "${cpp_output}"
    
    cat > "${entrypoint_cpp}" <<ENTRY_EOF
// Auto-generated AOT entrypoint for ${module_name}
// Uses pre-compiled jank code (no runtime evaluation needed!)
#include <cstdio>
#include <exception>
#include <jank/runtime/context.hpp>
#include <jank/runtime/core/to_string.hpp>
#include <jank/error.hpp>

// jank C API
extern "C" {
  int jank_init(int argc, char const** argv, bool init_ctx, int (*fn)(int, char const**));
  void* jank_load_clojure_core_native();
  void* jank_load_core();
  void* jank_load_set();
  void* jank_setup_clojure_core_for_wasm();

  // Dependency module init functions
$(echo -e "${deps_extern}")
  // Main module init function (returns void* which is an erased object_ref)
  void* jank_load_${munged_module_name}();
}

static void* safe_load_module() {
  using namespace jank;
  using namespace jank::runtime;
  try {
    printf("[jank-wasm] Now calling the actual load function...\\n");
    return jank_load_${munged_module_name}();
  } catch(error_ref const& e) {
    printf("[jank-wasm] jank error during load: %s\\n", e->message.c_str());
    return nullptr;
  } catch(oref<object> const& e) {
    printf("[jank-wasm] jank oref exception during load: %s\\n", to_string(e).c_str());
    return nullptr;
  } catch(std::exception const& e) {
    printf("[jank-wasm] C++ std::exception during load: %s\\n", e.what());
    return nullptr;
  } catch(...) {
    printf("[jank-wasm] Unknown C++ exception during load\\n");
    return nullptr;
  }
}

static int jank_main(int argc, char const** argv) {
  using namespace jank;
  using namespace jank::runtime;
  try {
    printf("[jank-wasm] AOT mode: using pre-compiled code\\n");

    // Load core native functions
    printf("[jank-wasm] Loading clojure.core-native...\\n");
    jank_load_clojure_core_native();
    printf("[jank-wasm] Core native loaded!\\n");

    // Set up clojure.core namespace by referring all vars from clojure.core-native
    printf("[jank-wasm] Setting up clojure.core namespace...\\n");
    jank_setup_clojure_core_for_wasm();
    printf("[jank-wasm] clojure.core ready!\\n");

    // Load full clojure.core from AOT-compiled jank code
    printf("[jank-wasm] Loading clojure.core (WASM-compatible subset)...\\n");
    jank_load_core();
    __rt_ctx->module_loader.set_is_loaded("clojure.core");
    printf("[jank-wasm] clojure.core loaded!\\n");

    // Load clojure.set if available
    printf("[jank-wasm] Loading clojure.set...\\n");
    jank_load_set();
    __rt_ctx->module_loader.set_is_loaded("clojure.set");
    printf("[jank-wasm] clojure.set loaded!\\n");
    printf("\\n");

    // Load dependencies
$(echo -e "${deps_load}")
    // Call the pre-compiled module
    printf("[jank-wasm] Executing pre-compiled module: ${module_name}\\n");
    void* result = safe_load_module();
    if(!result) {
      printf("[jank-wasm] Module load failed!\\n");
      return 1;
    }
    printf("[jank-wasm] Result: %p\\n", result);

    printf("\\n[jank-wasm] Done (AOT mode)!\\n");
    return 0;
  } catch(error_ref const& e) {
    printf("[jank-wasm] jank error: %s\\n", e->message.c_str());
    return 1;
  } catch(object_ref const& e) {
    printf("[jank-wasm] jank exception: %s\\n", to_string(e).c_str());
    return 1;
  } catch(std::exception const& e) {
    printf("[jank-wasm] C++ exception: %s\\n", e.what());
    return 1;
  } catch(...) {
    printf("[jank-wasm] Unknown C++ exception\\n");
    return 1;
  }
}

int main(int argc, char const** argv) {
  printf("[jank-wasm] jank WebAssembly Runtime (AOT)\\n");
  printf("[jank-wasm] Module: ${module_name}\\n");
  printf("\\n");
  
  printf("[jank-wasm] Calling jank_init...\\n");
  return jank_init(argc, argv, true, jank_main);
}
ENTRY_EOF
  else
    # Fallback: embed source and evaluate at runtime (limited functionality in WASM)
    echo "[emscripten-bundle] NOTE: jank WASM support is experimental."
    echo "[emscripten-bundle] Falling back to runtime evaluation mode."
    echo "[emscripten-bundle] Only parsing will work - full evaluation requires clojure.core."
    echo ""
    
    cat > "${cpp_output}" <<CPP_EOF
// Placeholder for ${module_name} - runtime eval mode
// Full AOT compilation requires clojure.core to be pre-compiled.
#include <cstdio>

extern "C" void jank_${module_name}_placeholder() {
  printf("[jank-wasm] Module '${module_name}' using runtime eval mode\\n");
}
CPP_EOF

    compiled_objects+=("${cpp_output}")
    
    # Generate a simple entrypoint that initializes the jank runtime
    entrypoint_cpp="${output_dir}/${module_name}_entry.cpp"
    
    cat > "${entrypoint_cpp}" <<ENTRY_EOF
// Auto-generated entrypoint for ${module_name}
// Initializes the jank WASM runtime
#include <cstdio>

// Embedded jank source code (using raw string literal)
static char const* const jank_source_code = R"JANK(${jank_source_content})JANK";

// jank C API - defined in c_api_wasm.cpp
extern "C" {
  // Runtime initialization
  int jank_init(int argc, char const** argv, bool init_ctx, int (*fn)(int, char const**));
  
  // Core library loading
  void* jank_load_clojure_core_native();
  
  // Evaluate jank source and get result as string
  char const* jank_eval_string_c(char const* s);
  
  // Module placeholder
  void jank_${module_name}_placeholder();
}

static int jank_main(int argc, char const** argv) {
  printf("[jank-wasm] Inside jank_main, runtime context should be initialized\\n");
  
  // Load core native functions
  printf("[jank-wasm] Loading clojure.core-native...\\n");
  jank_load_clojure_core_native();
  printf("[jank-wasm] Core native loaded!\\n");
  printf("\\n");
  
  // Evaluate the embedded jank source
  printf("[jank-wasm] Evaluating jank source...\\n");
  printf("[jank-wasm] Source:\\n%s\\n\\n", jank_source_code);
  
  char const* result = jank_eval_string_c(jank_source_code);
  printf("[jank-wasm] Result: %s\\n", result);
  
  printf("\\n[jank-wasm] Done!\\n");
  return 0;
}

int main(int argc, char const** argv) {
  printf("[jank-wasm] jank WebAssembly Runtime\\n");
  printf("[jank-wasm] Module: ${module_name}\\n");
  printf("\\n");
  
  printf("[jank-wasm] Calling jank_init...\\n");
  return jank_init(argc, argv, true, jank_main);
}
ENTRY_EOF
  fi
  
  echo "[emscripten-bundle] Generated entrypoint: ${entrypoint_cpp}"
fi

pushd "${repo_root}" >/dev/null

if [[ "${skip_build}" != "true" ]]; then
  configure_cmd=(
    emcmake
    cmake
    -S
    .
    -B
    "${build_dir}"
    -Djank_target_wasm=on
  )
  if [[ ${#cmake_args[@]} -gt 0 ]]; then
    configure_cmd+=("${cmake_args[@]}")
  fi

  run "${configure_cmd[@]}"

  run cmake --build "${build_dir}"
fi

# --- Link step: generate .js/.wasm/.html ---
echo "[emscripten-bundle] Linking into ${output_dir}/${output_name}.js ..."

libjank="${build_dir}/libjank.a"
libjankzip="${build_dir}/libjankzip.a"
libgc="${build_dir}/third-party/bdwgc/libgc.a"

for lib in "${libjank}" "${libjankzip}" "${libgc}"; do
  if [[ ! -f "${lib}" ]]; then
    echo "error: required library not found: ${lib}" >&2
    echo "       Run without --skip-build first." >&2
    exit 1
  fi
done

# Emscripten linking flags
# Note: jank wasm build is a library, not an executable, so we don't export main
# Instead, we create a module that can be loaded and used via ccall/cwrap

# Include paths for generated C++ that needs jank headers
jank_include_flags=(
  -I"${repo_root}/include/cpp"
  -I"${repo_root}/third-party/immer"
  -I"${repo_root}/third-party/bdwgc/include"
  -I"${repo_root}/third-party/folly"
  -I"${repo_root}/third-party/bpptree/include"
  -I"${repo_root}/third-party/cli11/include"
  -I"${repo_root}/third-party/boost-preprocessor/include"
  -I"${repo_root}/third-party/boost-multiprecision/include"
)

# Compiler flags for emscripten compatibility (must match CMakeLists.txt WASM build flags)
jank_compile_flags=(
  -std=c++20
  -D_LIBCPP_HAS_NO_INCOMPLETE_FORMAT
  -D_LIBCPP_HAS_NO_LOCALIZATION
  -DIMMER_HAS_LIBGC=1
  -DIMMER_TAGGED_NODE=0
  -DHAVE_CXX14=1
  -DFOLLY_HAVE_JEMALLOC=0
  -DFOLLY_HAVE_TCMALLOC=0
  -DFOLLY_ASSUME_NO_JEMALLOC=1
  -DFOLLY_ASSUME_NO_TCMALLOC=1
  -DJANK_TARGET_EMSCRIPTEN
  -DJANK_TARGET_WASM=1
  -Wno-invalid-constexpr
)

em_link_cmd=(
  em++
  -o "${output_dir}/${output_name}.js"
  "${libjank}"
  "${libjankzip}"
  "${libgc}"
  "${jank_include_flags[@]}"
  "${jank_compile_flags[@]}"
)

# Add compiled objects if any
for obj in "${compiled_objects[@]}"; do
  if [[ -f "${obj}" ]]; then
    em_link_cmd+=("${obj}")
  fi
done

# Add entrypoint if we have one
if [[ -n "${entrypoint_cpp}" && -f "${entrypoint_cpp}" ]]; then
  em_link_cmd+=("${entrypoint_cpp}")
  # With entrypoint, we can export main
  em_link_cmd+=(
    -sEXPORTED_FUNCTIONS=_main
  )
else
  # Without entrypoint, don't require main
  em_link_cmd+=(
    -sSTANDALONE_WASM=0
    -sERROR_ON_UNDEFINED_SYMBOLS=0
    -Wno-undefined
  )
fi

em_link_cmd+=(
  # Memory settings
  -sALLOW_MEMORY_GROWTH=1
  -sINITIAL_MEMORY=67108864
  # Enable C++ exceptions for better debugging
  -fexceptions
  # Export settings for JS interop
  -sEXPORTED_RUNTIME_METHODS=ccall,cwrap,UTF8ToString,stringToUTF8
  # Module settings
  -sMODULARIZE=1
  -sEXPORT_NAME="${output_name}"
  # Environment support
  -sENVIRONMENT=web,node
  # Error handling
  -sABORTING_MALLOC=0
  # Enable RTTI for exception handling
  -frtti
)

# Check if shell file exists for HTML generation
shell_file="${repo_root}/doc/jank-shell.html"
generate_html=false

if [[ -f "${shell_file}" ]]; then
  generate_html=true
  # Also generate HTML output
  em_html_cmd=(
    em++
    -o "${output_dir}/${output_name}.html"
    "${libjank}"
    "${libjankzip}"
    "${libgc}"
    "${jank_include_flags[@]}"
    "${jank_compile_flags[@]}"
  )
  
  # Add compiled objects if any
  for obj in "${compiled_objects[@]}"; do
    if [[ -f "${obj}" ]]; then
      em_html_cmd+=("${obj}")
    fi
  done
  
  # Add entrypoint if we have one
  if [[ -n "${entrypoint_cpp}" && -f "${entrypoint_cpp}" ]]; then
    em_html_cmd+=("${entrypoint_cpp}")
    em_html_cmd+=(-sEXPORTED_FUNCTIONS=_main)
  else
    em_html_cmd+=(
      -sSTANDALONE_WASM=0
      -sERROR_ON_UNDEFINED_SYMBOLS=0
      -Wno-undefined
    )
  fi
  
  em_html_cmd+=(
    -sALLOW_MEMORY_GROWTH=1
    -sINITIAL_MEMORY=67108864
    -sEXPORTED_RUNTIME_METHODS=ccall,cwrap,UTF8ToString,stringToUTF8
    -sENVIRONMENT=web,node
    -sABORTING_MALLOC=0
    --shell-file "${shell_file}"
  )
fi

# Run the JS/WASM generation
run "${em_link_cmd[@]}"

# Optionally generate HTML too (separate file for browser testing)
if [[ "${generate_html}" == "true" ]]; then
  run "${em_html_cmd[@]}"
  echo "[emscripten-bundle] Generated: ${output_dir}/${output_name}.html"
fi

echo "[emscripten-bundle] Generated: ${output_dir}/${output_name}.js"
echo "[emscripten-bundle] Generated: ${output_dir}/${output_name}.wasm"

# --- Run step (optional) ---
if [[ "${run_after}" == "true" ]]; then
  echo "[emscripten-bundle] Running with Node.js..."
  
  # The generated .js file uses UMD format, which works better with CommonJS require
  # Rename to .cjs to avoid ES module conflicts with package.json "type": "module"
  js_as_cjs="${output_dir}/${output_name}.cjs"
  if [[ -f "${output_dir}/${output_name}.js" ]]; then
    cp "${output_dir}/${output_name}.js" "${js_as_cjs}"
  fi
  
  # Create a simple runner script using CommonJS
  runner_script=$(mktemp -t jank-runner.XXXXXXXXXX.cjs)
  cat > "${runner_script}" <<EOF
const moduleFactory = require('${js_as_cjs}');

console.log('[jank-runner] Loading WASM module...');
moduleFactory().then(() => {
  console.log('[jank-runner] Module executed successfully');
}).catch(e => {
  console.error('[jank-runner] Error:', e);
  process.exit(1);
});
EOF

  node_cmd=(node)
  if [[ ${#node_args[@]} -gt 0 ]]; then
    node_cmd+=("${node_args[@]}")
  fi
  node_cmd+=("${runner_script}")
  run "${node_cmd[@]}"
  rm -f "${runner_script}"
fi

cat <<EOF
[emscripten-bundle] Build complete!

Generated files:
  - ${output_dir}/${output_name}.js    (ES module loader)
  - ${output_dir}/${output_name}.wasm  (WebAssembly binary)
EOF

if [[ "${generate_html}" == "true" ]]; then
  cat <<EOF
  - ${output_dir}/${output_name}.html  (Browser test page)

To test in browser:
  emrun ${output_dir}/${output_name}.html
  # or
  python3 -m http.server -d ${output_dir} 8080
  # then open http://localhost:8080/${output_name}.html
EOF
fi

cat <<EOF

To run with Node.js:
  node --experimental-vm-modules -e "import('${output_dir}/${output_name}.js').then(m => m.default())"
  # or
  $0 --skip-build --run
EOF

popd >/dev/null
