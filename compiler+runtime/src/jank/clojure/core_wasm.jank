;; Minimal WASM-compatible clojure.core
;; Contains essential functions without C++ interop
(ns clojure.core)

(defn map
  "Returns a lazy sequence consisting of the result of applying f to
   the set of first items of each coll, followed by applying f to the
   set of second items in each coll, until any one of the colls is
   exhausted.  Any remaining items in other colls are ignored. Function
   f should accept number-of-colls arguments."
  ([f coll]
   (lazy-seq
     (when-let [s (seq coll)]
       (cons (f (first s)) (map f (rest s))))))
  ([f c1 c2]
   (lazy-seq
     (let [s1 (seq c1) s2 (seq c2)]
       (when (and s1 s2)
         (cons (f (first s1) (first s2))
               (map f (rest s1) (rest s2)))))))
  ([f c1 c2 c3]
   (lazy-seq
     (let [s1 (seq c1) s2 (seq c2) s3 (seq c3)]
       (when (and s1 s2 s3)
         (cons (f (first s1) (first s2) (first s3))
               (map f (rest s1) (rest s2) (rest s3))))))))

(defn filter
  "Returns a lazy sequence of the items in coll for which
   (pred item) returns logical true. pred must be free of side-effects.
   Returns a transducer when no collection is provided."
  ([pred coll]
   (lazy-seq
     (when-let [s (seq coll)]
       (let [f (first s) r (rest s)]
         (if (pred f)
           (cons f (filter pred r))
           (filter pred r)))))))

(defn reduce
  "f should be a function of 2 arguments. If val is not supplied,
   returns the result of applying f to the first 2 items in coll, then
   applying f to that result and the 3rd item, etc. If coll contains no
   items, f must accept no arguments as well, and reduce returns the
   result of calling f with no arguments.  If coll has only 1 item, it
   is returned and f is not called.  If val is supplied, returns the
   result of applying f to val and the first item in coll, then
   applying f to that result and the 2nd item, etc. If coll contains no
   items, returns val and f is not called."
  ([f coll]
   (if-let [s (seq coll)]
     (reduce f (first s) (rest s))
     (f)))
  ([f val coll]
   (if-let [s (seq coll)]
     (recur f (f val (first s)) (rest s))
     val)))

(defn mapv
  "Returns a vector consisting of the result of applying f to the
   set of first items of each coll, followed by applying f to the set
   of second items in each colls, until any one of the colls is
   exhausted.  Any remaining items in other colls are ignored. Function
   f should accept number-of-colls arguments."
  ([f coll]
   (persistent! (reduce (fn [v x] (conj! v (f x))) (transient []) coll)))
  ([f c1 c2]
   (into [] (map f c1 c2)))
  ([f c1 c2 c3]
   (into [] (map f c1 c2 c3))))

(defn into
  "Returns a new coll consisting of to-coll with all of the items of
   from-coll conjoined. A transducer may be supplied."
  ([to from]
   (reduce conj to from)))

(defn take
  "Returns a lazy sequence of the first n items in coll, or all items if
   there are fewer than n.  Returns a transducer when n is the only value."
  [n coll]
  (lazy-seq
    (when (pos? n)
      (when-let [s (seq coll)]
        (cons (first s) (take (dec n) (rest s)))))))

(defn drop
  "Returns a lazy sequence of all but the first n items in coll.
   Returns a transducer when n is the only value."
  [n coll]
  (lazy-seq
    (let [s (seq coll)]
      (if (and (pos? n) s)
        (drop (dec n) (rest s))
        s))))

(defn concat
  "Returns a lazy seq representing the concatenation of the elements in the supplied colls."
  ([] (lazy-seq nil))
  ([x] (lazy-seq x))
  ([x y]
   (lazy-seq
     (let [s (seq x)]
       (if s
         (cons (first s) (concat (rest s) y))
         y))))
  ([x y & zs]
   (concat (concat x y) (apply concat zs))))

(defn mapcat
  "Returns the result of applying concat to the result of applying map
   to f and colls.  Thus function f should return a collection. Returns
   a transducer when no collections are provided"
  ([f]
   (comp (map f) cat))
  ([f & colls]
   (apply concat (apply map f colls))))

(defn even?
  "Returns true if n is even, throws an exception if n is not an integer"
  [n]
  (zero? (bit-and n 1)))

(defn odd?
  "Returns true if n is odd, throws an exception if n is not an integer"
  [n]
  (not (even? n)))
