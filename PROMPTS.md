# Prompts

## Prompt 1 (November 25, 2025)

Don't generate C++ code, generate LLVM IR to WASM as the C++ generation is broken!! Also, I've exported some env vars and the native build should be working now. Go, iterate! Fix it!!

Use eita.jank as your test file, we shoukld make it work so we can have the run working cleanly just like it does using the native jank. 

Don't use /dev/null nor /tmp (create temp files inside the repo as needed) !!

Ok, focus! You have a libjank.a for wasm, correct? You have the clojure.core.o object for wasm as well? If not generate it (this exists for the native one after phase 1, create this!!!)

----

## Prompt 2 (November 25, 2025)

Don't generate C++ (it's broken), genereate llvm IR!!

----

## Prompt 3 (November 25, 2025)

Add a one-liner (or add to the emscripten-bundle) so we just run it just by passing the .jank file.

Also now, run the real eita2.jank, we have a `refer` inside clojure/core.jank, so it should work!! Fix it

----

## Prompt 4 (November 25, 2025)

No, don't modify core_native to add refer!! The WASM should use the clojure/core.jank one!! Check how the native one is using and replicate so we can use it from the WASM side!!

----

## Prompt 5 (November 25, 2025)

Ok, merge the branch from https://github.com/jank-lang/jank/pull/598 so we can have C++ codegen working!!

----

## Prompt 6 (November 25, 2025)

Ok, fix this error!! 

But don't worry, these errors happen in the PR build \o So leave them! Also don't forget to update PROMPTS and AGENTS_CONTEXT

Also, see if you can now use the c++ code gen for wasm!! It should be working

----

## Prompt 7 (November 26, 2025)

Ok, in the emscripten-bundle script, the wasm node version was running, but I was having error when running the browser version, fix that, please!

----

## Prompt 8 (November 26, 2025)

Now, modify it so we can call a function from the generated wasm by passing a number (and logging the result!)

----

## Prompt 9 (November 26, 2025)

Ok, in eita.jank we have a function called `ggg`, now tell me how I would export is so I can use it to call it! from wasm in the browser using emscripten-bundle!

----

## Prompt 10 (November 26, 2025)

Ok, in eita.jank we have a function called `ggg`, now tell me how I would export is so I can use it to call it (it can be any object!!) from wasm in the browser using emscripten-bundle!

----

## Prompt 11 (November 26, 2025)

Ok, in eita.jank we have a function called `ggg`, now tell me how I would export is so I can use it to call it (it can be any object!!) from wasm in the browser using emscripten-bundle! Maybe, while aoting, we can check for a ^:export metadata in the symbol and export it, just like we do for `-main` (which becomes _main)

----

## Prompt 12 (November 26, 2025)

Don't use jank.export for WASM? Only ^:export should be enough for the browser to understand!!

----

## Prompt 13 (November 26, 2025)

I'm having the folllowing in the browser 

--- Calling ggg(42) ---
Found function: _jank_export_ggg
Error calling ggg: not a number: nil
ERROR: Function call error: std::runtime_error: not a number: nil

----

## Prompt 14 (November 26, 2025)

Now I'm having the folllowing in the browser 

--- Calling ggg(42) ---
Found function: _jank_export_ggg
Error calling ggg: Cannot convert 42 to a BigInt
ERROR: Function call error: TypeError: Cannot convert 42 to a BigInt

Maybe there is a easy way to convert primitives from js to wasm? Do it if so

----

## Prompt 15 (November 26, 2025)

How can we add source mapping to the wasm generated by emscripten-bundle ?

----

## Prompt 16 (November 26, 2025)

Ok, add it and generate for eita.jank !!

----

## Prompt 17 (November 29, 2025)

Regarding the nREPL autocompletion, `flecs/world` or `flecs/type` (for example), they work, but each of these they have nested members/functions/structs/whatever, e.g. using below works, but I don't have autocompletion for `flecs/world.defer_begin` for example, add support for it!! Fix it

  (let [w (flecs/world)]
         (flecs/world.defer_begin w)
         (flecs/world.defer_end w))

----

## Prompt 18 (November 29, 2025)

Not working see the nREPL engine.cpp test ! Create a hpp nested for testing so you can have `something/a.b` working and you can check that's autocompleted!!!

----

## Prompt 19 (November 29, 2025)

When I try to do ... , I have below, fix it! (crash in Cpp::GetAllCppNames when iterating incomplete/complex types like flecs::world)

----

## Prompt 20 (November 29, 2025)

Regarding the nREPL autocompletion, `flecs/world` or `flecs/type` (for example), they work, but each of these they have nested members/functions/structs/whatever, e.g. using below works, but I don't have autocompletion for `flecs/world.` for example, then we could have `flecs/world.deref_begin` or whatever, add support for it!! Fix it! Create a test in nREPL cpp engine.cpp reproducing the issue 

```
(ns my-flecs-static
  (:require
   ["flecs.h" :as flecs]
   #_["flecs.h" :as f-w :scope "world"]))

  (let [w (flecs/world)]
         (flecs/world.defer_begin w)
         (flecs/world.defer_end w))
```

And flecs.h would be something like (it's truncated, just an example)

```
namespace flecs
{

/* Static helper functions to assign a component value */

// set(T&&)
template <typename T>
inline void set(world_t *world, flecs::entity_t entity, T&& value, flecs::id_t id) {
    ecs_assert(_::type<T>::size() != 0, ECS_INVALID_PARAMETER,
            "operation invalid for empty type");

    ecs_cpp_get_mut_t res = ecs_cpp_set(world, entity, id, &value, sizeof(T));

    T& dst = *static_cast<remove_reference_t<T>*>(res.ptr);
    if constexpr (std::is_copy_assignable_v<T>) {
        dst = FLECS_FWD(value);
    } else {
        dst = FLECS_MOV(value);
    }

    if (res.call_modified) {
        ecs_modified_id(world, entity, id);
    }
}

// ... more code ...

struct world {
    /** Create world.
     */
    explicit world()
        : world_( ecs_init() ) { 
            init_builtin_components(); 
        }
    // ... members like defer_begin, defer_end, etc.
}
```

## Prompt 13 (November 29, 2025)

Regarding the nREPL autocompletion, `flecs/world` or `flecs/type` (for example), they work, but each of these they have nested members/functions/structs/whatever, e.g. using below works, but I don't have autocompletion for `flecs/world.` for example, then we could have `flecs/world.deref_begin` or whatever, add support for it!! Fix it! Create a test in nREPL cpp engine.cpp reproducing the issue 

```clojure
(ns my-flecs-static
  (:require
   ["flecs.h" :as flecs]
   #_["flecs.h" :as f-w :scope "world"]))

  (let [w (flecs/world)]
         (flecs/world.defer_begin w)
         (flecs/world.defer_end w))
```

And flecs.h would be something like (it's truncated, just an example)

```cpp
namespace flecs
{

/* Static helper functions to assign a component value */

// set(T&&)
template <typename T>
inline void set(world_t *world, flecs::entity_t entity, T&& value, flecs::id_t id) {
    // ... truncated
}

struct world {
    /** Create world.
     */
    explicit world()
        : world_( ecs_init() ) { 
            init_builtin_components(); 
        }
    // ... members like defer_begin, defer_end, etc.
}
```

## Prompt 14 (November 29, 2025)

When I try to autocomplete (from cider using nrepl) flecs/world. , it crashes the server!! 

```
Process 8944 stopped
* thread #17, stop reason = EXC_BAD_ACCESS (code=1, address=0x8)
    frame #0: 0x0000000100006278 jank`llvm::detail::PunnedPointer<clang::Decl*>::asInt(this=0x0000000000000008) const at PointerIntPair.h:41:5
...
    frame #6: Cpp::GetAllCppNames(scope=0x00000001304a0cc0, names=size=0) at CppInterOp.cpp:5490:7
    frame #7: jank::nrepl_server::asio::enumerate_type_members(...)
```

## Prompt 15 (November 29, 2025)

Fetch https://github.com/SanderMertens/flecs/blob/master/include/flecs/addons/cpp/world.hpp , and replicate this issue in the test!! Then fix it!!

## Prompt 16 (November 29, 2025)

At line 1110 of compiler+runtime/test/cpp/jank/nrepl/engine.cpp , there should exist completions!! Don't cheat, fix it!!
